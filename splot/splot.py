import numpy as np
import matplotlib.pyplot as plt
from matplotlib.ticker import MaxNLocator
import itertools
plt.style.use('../splot/styles/billinge.mplstyle')
c = [color['color'] for color in list(plt.rcParams['axes.prop_cycle'])]

def data_dict(data, samplename='none', scan='scan', **kwargs):
    """Make a data dictionary with keys: data, samplename, scanname,
    and optional keys to specify plotting style: line, color, and marker.

    Parameters:
    -------------
    data:tuple
        (x, y) where x and y each is an array for plotting
    samplename: str
        sample name
    scan: str
        scan name
    **kwargs: dict
        kwargs for line styling passed to plt.plot

    Returns: dict
    --------
        A dictionary with keys 'data', 'samplename', 'scanname' (and kwargs)
    """
    d = {}
    d['samplename'] = samplename
    d['scanname'] = samplename + scan
    d['data'] = data
    d.update(kwargs)
    return d

class Splot:
    """Contains functions for quick plotting as Billinge Group Standard figures.

    User must generate a data dictionary by the data function in this module.
    This class only handles plotting.

    Attributes:
    -------------
    row: int
        the number of rows in the plotting panel. Default value is 1 row.
    col: int
        the number of columns in the plotting panel. Default value is 1 column.
    fig: object
        the figure object in matplotlib.
    ax: ndarray
        a 2D array of same number of rows and cols as in the plotting panel.
        Each entry contains a matplotlib axes to plot each subplot.
    axbig: oject
        a matplotlib axes to make tile and labels for overall plot.
    legends: tuple
        in the form of (lines, labels)
        where the lines is an array of line objects
        and the labels is an array of the scan names of the data that are used
        as the legends in the figure.
    subd: ndarry
        a 2D array of same number of rows and cols as in the plotting panel.
        Each entry is a tuple (x, y) where x is a list of x arrays plotted
        in the subplot and y is a list of the correponding y arrays.
    """

    def __init__(self, r=1, c=1):
        """Create a new plotting panel as r rows by c colums."""
        self.whitelist = ['samplename']
        self.row, self.col = r, c
        self.fig, self.ax = plt.subplots(self.row,  self.col,
                                         sharex='col', sharey='row',)
                                         
        self.fig.tight_layout()
        self.axbig = self.fig.add_subplot(111, frameon = False)
        self.axbig.tick_params(labelcolor ='none',
                               top ='off', bottom ='off',
                               left ='off', right ='off')
        self.axbig.grid(False)
        self.legends = ([], [])
        self.subd = np.empty( (self.row,  self.col), object)
        for i, j in itertools.product(range(r), range(c)):
            self.subd[i,j] = ([], [])
        self.fig.subplots_adjust(wspace = 0.0, hspace = 0.0)
        if r == 1 and c == 1:
            self.ax = np.array([self.ax]).reshape(-1, 1)
        elif r == 1 or c == 1:
            self.ax = self.ax.reshape((r, c))
        return

    def plot_data(self, data, scanname, r=0, c=0, \
               scal=1, offsetx=0, offsety=0, diff=False, legend=None, **kwargs):
        """Plot data.

        Parameters:
        -------------
        d: dictionary
           a data dictionary generated by the data() function.
        r and c: int
           Optional when figure has a sinlge plot.
           r and c refers to the subpolot postition of
           where the data is being plotted.
           Default position is subplot(0,0) if the figure has multi subplots.
        scal:float, optional
            scaling factor for the y range of data in plotting.
            Default value is 1 as no scaling is applied.
        offsetx: float, optional
            the amount of offset on x axis when plot data.
        offsety: float, optional
            the amount of offset on y axis when plot data.
        diff: bool, optional
            When set to be True, the subplot will include the diffrence curve
            of the first two curves plotted in the same subplot.
        legend:str, optional
            To create the legend for the plot.
            Value choices are "In" and "Out".
            When set to "In", each subplot will have its own legend.
            When set to "Out", there is only one overall lengend
            outside of the plot for all lines plotted in the figure.
        **kwargs: dict
            kwargs passed to plt.plot

        Return:
        --------
        A updated figure.
        """
        for k in self.whitelist:
            kwargs.pop(k)
        line, = self.ax[r, c].plot(data[0] + offsetx, data[1]*scal + offsety, \
                                    label = scanname, **kwargs)
        self.add_data(data, r, c)
        if scanname not in self.legends[1]:
            self.legends[0].append(line)
            self.legends[1].append(scanname)
        if diff == True:
            self.diff_c(r, c)
        self.ticks()
        self.label()
        self.title()
        self.legend(disp = legend)
        return

    def add_data(self, d, r, c):
        """helper method for plotData() to update subd.

        Parameters:
        -------------
        d: dictionary
         a data dictionary generated by the data() function.
        r and c: int
         the row and col number of the subplot where the data is being plotted.

        Return:
        --------
        subd: ndarray
            updated subd.
        """
        self.subd[r, c][0].append( d[0] )
        self.subd[r, c][1].append( d[1] )
        return self.subd

    def diff_c(self, r=0, c=0, scal=1, offset=None):
        """Method to plot the difference curve at subplot(r, c),
        also a helper function for plotData()

        Parameters:
        -------------
        r and c: int
           Optional when figure has a sinlge plot.
           r and c refers to the subpolot postition of
           where the difference curve is being plotted.
           Default position is subplot(0,0) if the figure has multi subplots.
        scal:float, optional
            Scaling factor for the y range of difference curve in plotting.
            Default value is 1 as no scaling is applied.
        offset: float, optional
            the amount of offset on y axis when plot the diff Curve.
            Default value is None, where the peak of the diff curve is
            seperated by %10 of the data range below the lower curve.
            
        Raise:
        ------
        ValueError:
            when plot the diff curve and subplot doesn't have exactly 2 curves. 
        """
        if len (self.subd[r, c][1]) != 2:
            raise ValueError( "subplot(%d, %d) must have EXACTLY 2 curves \
                     to calcualte the diff Curve, now you have %d curves here."
                     %(r, c, len (self.subd[r, c][1]) ) )
         ## Need to ask.
        diffy = self.subd[r,c][1][0] - self.subd[r, c][1][1]
        if offset == None:
            h = max (self.subd[r, c][1][0].max(), self.subd[r, c][1][1].max())
            l = min (self.subd[r, c][1][0].min(), self.subd[r, c][1][1].min() )
            amp = h-l
            offset = l - diffy.max() - amp*0.1
        line, = self.ax[r, c].plot( self.subd[r,c][0][0], diffy*scal + offset,\
                                     label = 'diff')
        plt.setp(line, color = 'g')
        plt.setp(line, linestyle = '-')
        if "diff" not in self.legends[1]:
            self.legends[0].append(line)
            self.legends[1].append('diff')
        return

    def ticks(self):
        """helper method for plotData() to remove the overlapping ticks."""
        nbins = 6                   
        for i in range(self.row):
            self.ax[i, 0].yaxis.set_major_locator(\
                        MaxNLocator(nbins, prune='both'))
            self.ax[i, 0].minorticks_on()
        for i in range(self.col):
            self.ax[-1, i].xaxis.set_major_locator(
                            MaxNLocator(nbins, prune='both'))
            self.ax[-1, i].minorticks_on()
        return

    def label(self, x='r', xunit='AA', y='G', yunit='AA^{-2}', math=True):
        """Method generate labels for axis in the overall plot.

        Parameters:
        -------------
        x: str, optional
          the label for x axis. Default value is 'r' as in a G(r) plot
        xunit: str, optional
          unit for the x axis.
          Default value is 'AA', a Latex command for Angstrom.
          To see this Math symbol, the 'math' parameter has to be 'True'.
        y: str, optional
          the label for y axis. Default value is 'G' as in a G(r) plot
        yunit: str, optional
          unit for the y axis.
          Default value is 'AA^{-2}' for G(r)
          a Latex command for the inverse square of Angstrom.
          To see the Math symbol, the 'math' parameter has to be 'True'.
        math: bool, optional
          Ture: default value. Turn on the math expression for the labels.
          False: write the labels as normal text.
        """
        if math:
            xl = r'$\mathrm{%s}\  \mathrm{( \%s )}$' %(x, xunit)
            yl = r'$\mathrm{%s}\  \mathrm{( \%s )}$' %(y, yunit)
        else:
            xl = '%s (%s)' %(x, xunit)
            yl = '%s (%s)' %(y, yunit)
        self.axbig.set_xlabel(xl)
        self.axbig.set_ylabel(yl)
        return

    def title(self, t='', math=False):
        """Method generate labels for axis.

        Parameters:
        -------------
        t: str, optional
         the tile of the overal plot.
         Default to be empty.
        math: bool, optional
          Ture: Turn on the math expression for the labels.
          False: default. Write the labels as normal text.
        """
        if math:
            t = r'$\mathrm{%s} $' %t
        return self.axbig.set_title(t)

    def legend(self, disp=None):
        """Method to create legend for the figure.

        Parameters:
        -------------
        disp: str, optional
            Chose if the legend is outside or inside of the plotting area.
            "None": default value. No legend on the plot.
            "out": an overall outside legend for all lines in the figure
            "in": each subplot has its own legend.
        """
        if disp:
            if disp == 'out':
                self.legend_out()
            if disp == 'in':
                self.legend_in()
        return

    def legend_out(self):
        """helper method for the legend(), creating an overall legend
        for all lines. The legend is outside of the plotting box."""
        return plt.legend(self.legends[0], self.legends[1], loc='center left',
                   bbox_to_anchor = (1, 0.6), borderaxespad=0, \
                   labelspacing= 1., prop={'size':8}, handlelength = 3)

    def legend_in(self):
        """helper method for the legend(),
        creating legends inside of each subplot."""
        for i, j in itertools.product(range(self.row), range(self.col)):
            self.ax[i,j].legend(loc = 'upper right', \
                                labelspacing= 1.,
                                prop={'size':8}, handlelength = 3)
        return

    def save(self, name="myplot", form="pdf"):
        """Save the plot to the current working diretory.

        Parameters:
        -------------
        name: str
            the name of plot being saved.
        form:str, optional
            the form of figure file. Example, png, eps, pdf.
        """
        return self.fig.savefig( '%s.%s' %(name, form) )

    def show(self):
        """Show figure in a GUI window."""
        return self.fig.show()

    def figure_size(self, width, height):
        """Change the current figure shape or size"""
        self.fig.set_figwidth(width)
        self.fig.set_figheight(height)
        return

    def set_xlim(self, col, low, high):
        """ a method to manually set the x range in plot.

        Parameters:
        -------------
        col: int
            the column at which the shared x-axis limit should be set.
        low: float
            the lower bound of the x-axis being set.
        high: float
            the higher bound of the x-axis being set.
        """
        return self.ax[0,col].set_xlim([low, high])

    def sety_ylim(self, row, low, high):
        """ a method to manually set the shared y range in the plot.

        Parameters:
        -------------
        row: int
            the row at which the shared y-axis limit should be set.
        low: float
            the lower bound of the y-axis being set.
        high: float
            the higher bound of the y-axis being set.
        """
        return self.ax[row,0].set_ylim([low, high])