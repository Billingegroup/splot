import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt
from matplotlib.ticker import MaxNLocator
import itertools
from pylab import rcParams
#rcParams['figure.figsize'] = 12, 8

plt.style.use('styles/billinge.mplstyle')
#plt.style.use('../splot/styles/mycopy.mplstyle')
c = [color['color'] for color in list(rcParams['axes.prop_cycle'])]

def dataDict(data, samplename='none', scan='scan', **pltstyle):
    d = {}
    d['samplename'] = samplename
    d['scanname'] = samplename + scan
    d['data'] = data
    for key in pltstyle:
        d['style'] = {key: pltstyle[key]}
#    print ("keys in your data dict: ", d.keys())
    return d

class Splot:
    def __init__(self, r=1, c=1):
        """Create a new plotting panel as r rows by c colums."""
        self.row, self.col = r, c
        self.fig, self.ax = plt.subplots(self.row,  self.col,
                                         sharex='col', sharey='row')
        self.fig.tight_layout()
        self.axbig = self.fig.add_subplot(111, frameon = False)
        self.axbig.tick_params(labelcolor ='none',
                               top ='off', bottom ='off',
                               left ='off', right ='off')
        self.axbig.grid(False)
        self.legends = ([], [])
        self.subd = np.empty( (self.row,  self.col), object)
        for i, j in itertools.product(range(r), range(c)):
            self.subd[i,j] = ([], [])
        self.fig.subplots_adjust(wspace = 0.0, hspace = 0.0)
        if r == 1 and c == 1:
            self.ax = np.array([self.ax]).reshape(-1, 1)
        elif r == 1 or c == 1:
            self.ax = self.ax.reshape((r, c))
        return

    def plotData(self, d, r=0, c=0, scal=1, offsetx=0, offsety=0,
                 diff=False, legend=None):
        line, = self.ax[r, c].plot( d['data'][0] + offsetx, \
                                    d['data'][1]*scal + offsety, \
                                    label = d['scanname'])                                
        if 'style' in d:
            plt.setp(line, **d['style'])
        self.addData(d, r, c)
        if d['scanname'] not in self.legends[1]:
            self.legends[0].append(line)
            self.legends[1].append(d['scanname'])
        if diff == True:
            self.diffC(r, c)
        self.ticks()
        self.label()
        self.title()
        self.legend(disp = legend)
        return

    def addData(self, d, r, c):
        """helper method for plotData() to update subd.

        Parameters:
        -------------
        d: dictionary
         a data dictionary generated by the data() function.
        r and c: int
         the row and col number of the subplot where the data is being plotted.

        Return:
        --------
        subd: ndarray
            updated subd.
        """
        self.subd[r, c][0].append( d['data'][0] )
        self.subd[r, c][1].append( d['data'][1] )
        return self.subd

    def diffC(self, r=0, c=0, scal=1, offset=None):
        """Method to plot the difference curve at subplot(r, c),
        also a helper function for plotData()

        Parameters:
        -------------
        r and c: int
           Optional when figure has a sinlge plot.
           r and c refers to the subpolot postition of
           where the difference curve is being plotted.
           Default position is subplot(0,0) if the figure has multi subplots.
        scal:float, optional
            Scaling factor for the y range of difference curve in plotting.
            Default value is 1 as no scaling is applied.
        offset: float, optional
            the amount of offset on y axis when plot the diff Curve.
            Default value is None, where the peak of the diff curve is
            seperated by %10 of the data range below the lower curve.
        """
        if len (self.subd[r, c][1]) != 2:
            raise ValueError( "subplot(%d, %d) must have EXACTLY 2 curves \
                     to calcualte the diff Curve, now you have %d curves here."
                     %(r, c, len (self.subd[r, c][1]) ) )
         ## Need to ask.
        diffy = self.subd[r,c][1][0] - self.subd[r, c][1][1]
        if offset == None:
            h = max (self.subd[r, c][1][0].max(), self.subd[r, c][1][1].max())
            l = min (self.subd[r, c][1][0].min(), self.subd[r, c][1][1].min() )
            amp = h-l
            offset = l - diffy.max() - amp*0.1
        line, = self.ax[r, c].plot( self.subd[r,c][0][0], diffy*scal + offset,\
                                     label = 'diff')
        plt.setp(line, color = 'g')
        plt.setp(line, linestyle = '-')
        if "diff" not in self.legends[1]:
            self.legends[0].append(line)
            self.legends[1].append('diff')
        return

    def ticks(self):
        """helper method for plotData() to remove the overlapping ticks."""
#        nbins = len( self.ax[0, 0].get_xticklabels() )
        nbins = 6                   #??? fix a grid density
        for i in range(self.row):
            self.ax[i, 0].yaxis.set_major_locator(\
                        MaxNLocator(nbins, prune='both'))
            self.ax[i, 0].minorticks_on()
        for i in range(self.col):
            self.ax[-1, i].xaxis.set_major_locator(
                            MaxNLocator(nbins, prune='both'))
            self.ax[-1, i].minorticks_on()
        return

    def label(self, x='r', xunit='AA', y='G', yunit='AA^{-2}', math=True):
        """Method generate labels for axis in the overall plot.

        Parameters:
        -------------
        x: str, optional
          the label for x axis. Default value is 'r' as in a G(r) plot
        xunit: str, optional
          unit for the x axis.
          Default value is 'AA', a Latex command for Angstrom.
          To see this Math symbol, the 'math' parameter has to be 'True'.
        y: str, optional
          the label for y axis. Default value is 'G' as in a G(r) plot
        yunit: str, optional
          unit for the y axis.
          Default value is 'AA^{-2}' for G(r)
          a Latex command for the inverse square of Angstrom.
          To see the Math symbol, the 'math' parameter has to be 'True'.
        math: bool, optional
          Ture: default value. Turn on the math expression for the labels.
          False: write the labels as normal text.
        """
        if math:
            xl = r'$\mathrm{%s}\  \mathrm{( \%s )}$' %(x, xunit)
            yl = r'$\mathrm{%s}\  \mathrm{( \%s )}$' %(y, yunit)
        else:
            xl = '%s (%s)' %(x, xunit)
            yl = '%s (%s)' %(y, yunit)
        self.axbig.set_xlabel(xl)
        self.axbig.set_ylabel(yl)
        return

    def title(self, t='', math=False):
        """Method generate labels for axis.

        Parameters:
        -------------
        t: str, optional
         the tile of the overal plot.
         Default to be empty.
        math: bool, optional
          Ture: Turn on the math expression for the labels.
          False: default. Write the labels as normal text.
        """
        if math:
            t = r'$\mathrm{%s} $' %t
        return self.axbig.set_title(t)

    def legend(self, disp=None):
        """Method to create legend for the figure.

        Parameters:
        -------------
        disp: str, optional
            Chose if the legend is outside or inside of the plotting area.
            "None": default value. No legend on the plot.
            "out": an overall outside legend for all lines in the figure
            "in": each subplot has its own legend.
        """
        if disp:
            if disp == 'out':
                self.legendOut()
            if disp == 'in':
                self.legendIn()
        return

    def legendOut(self):
        """helper method for the legend(), creating an overall legend
        for all lines. The legend is outside of the plotting box."""
        return plt.legend(self.legends[0], self.legends[1], loc='center left',
                   bbox_to_anchor = (1, 0.6), borderaxespad=0, \
                   labelspacing= 1., prop={'size':8}, handlelength = 3)

    def legendIn(self):
        """helper method for the legend(),
        creating legends inside of each subplot."""
        for i, j in itertools.product(range(self.row), range(self.col)):
            self.ax[i,j].legend(loc = 'upper right', \
                                labelspacing= 1.,
                                prop={'size':8}, handlelength = 3)
        return

    def save(self, name="myplot", form="pdf"):
        """Save the plot to the current working diretory.

        Parameters:
        -------------
        name: str
            the name of plot being saved.
        form:str, optional
            the form of figure file. Example, png, eps, pdf.
        """
        return self.fig.savefig( '%s.%s' %(name, form) )

    def show(self):
        """Show figure in a GUI window."""
        return self.fig.show()

    #### Figure reshape Method 3: Similar to Method 1 or 2.
    ####This changes the overal figure shape. Recommend to use this one :)
    def figureSize(self, width, height):
        """Change the current figure shape or size"""
        self.fig.set_figwidth(width)
        self.fig.set_figheight(height)
        return

    #### Figure reshape Method 4: rescale subplot axes ratio.
    #### Doesn't work well, not recommend....
    def aspect(self, ratio):
        """ a method to change the aspect ratio in by a ratio factor.

        Note: this doesn't work well, because axis range in each subplot is
        rescaled by the same amount. When the ratio is not proper,
        part of the curve will be cut off in some subplot.

        Parameters:
        -------------
        ratio: float
            a factor to be multipled by the current aspect for all subplots.
            Example:
            ratio = 1 to maintain the auto scaled aspect ratio.
            ratio = 2 to half the auto aspect ratio (double x ranges with
            centering the data).
            ratio = 1/2 to double the auto aspect ratio (double y ranges with
            centering the data).

        Returns:
        --------
        An updated figure.
        """
        for i, j in itertools.product(range(self.row), range(self.col)):
            ll, ur = self.ax[i,j].get_position() * self.fig.get_size_inches()
            width, height = ur - ll
            axesratio = height / width
            aspect = axesratio / self.ax[i,j].get_data_ratio()
#            self.ax[i, j].set_aspect (ratio * aspect, adjustable='box-forced')
            # Cons: may sepearte the subplots
            self.ax[i, j].set_aspect (ratio * aspect)
            # Cons: may cut off part of the data
        return

    def setXLim(self, col, low, high):
        """ a method to manually set the x range in plot.

        Parameters:
        -------------
        col: int
            the column at which the shared x-axis limit should be set.
        low: float
            the lower bound of the x-axis being set.
        high: float
            the higher bound of the x-axis being set.
        """
        return self.ax[0,col].set_xlim([low, high])

    def setYLim(self, row, low, high):
        """ a method to manually set the shared y range in the plot.

        Parameters:
        -------------
        row: int
            the row at which the shared y-axis limit should be set.
        low: float
            the lower bound of the y-axis being set.
        high: float
            the higher bound of the y-axis being set.
        """
        return self.ax[row,0].set_ylim([low, high])